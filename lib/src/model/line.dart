// 直線の式を表すクラス (generated by ChatGPT-4o)
// 計算上の原点は、左下にある。
import 'dart:math';
import 'dart:ui';

class Line {
  final double? a; // 傾き (nullの場合は垂直線を意味する)
  final double b; // y切片またはx切片

  const Line(this.a, this.b);

  // 2点からLineオブジェクトを作成するコンストラクタ
  factory Line.fromPoints(Point<double> p1, Point<double> p2) {
    return Line(
      (p2.x != p1.x) ? (p2.y - p1.y) / (p2.x - p1.x) : null,
      (p2.x != p1.x) ? p1.y - ((p2.y - p1.y) / (p2.x - p1.x)) * p1.x : p1.x,
    );
  }

  factory Line.fromOffset(Offset p1, Offset p2) {
    return Line(
      (p2.dx != p1.dx) ? (p2.dy - p1.dy) / (p2.dx - p1.dx) : null,
      (p2.dx != p1.dx) ? p1.dy - ((p2.dy - p1.dy) / (p2.dx - p1.dx)) * p1.dx : p1.dx,
    );
  }


  // xからyを計算する
  double getY(double x) {
    if (a != null) {
      return a! * x + b;
    } else {
      return double.nan; // 垂直線の場合、任意のxに対してyを計算できない
    }
  }

  // yからxを計算する
  double getX(double y) {
    if (a != null) {
      if (a != 0) {
        return (y - b) / a!;
      } else {
        return y == b ? double.nan : double.nan; // 水平線の場合、yがbと等しいかどうかをチェック
      }
    } else {
      return b; // 垂直線の場合、xは常にb
    }
  }

  /// 式の角度を取得する (rad単位)
  double get angleInRadians {
    if (a != null) {
      return atan(a!);
    } else {
      return pi / 2; // 垂直線の場合は90度
    }
  }

  /// 式の角度を取得する (deg単位)
  double get angleInDegree => angleInRadians * 180 / pi;

  /// 他のLineクラスを入力して交点を求めるメソッド
  /// nullの場合、解なし
  Point<double>? getIntersection(Line other) {
    if (a == null && other.a == null) {
      // 両方とも垂直線の場合、交点はない
      return null;
    } else if (a == null) {
      // thisが垂直線の場合
      double x = b;
      double y = other.getY(x);
      return Point(x, y);
    } else if (other.a == null) {
      // otherが垂直線の場合
      double x = other.b;
      double y = getY(x);
      return Point(x, y);
    } else if (a == other.a) {
      // 平行線または同一線上の場合
      return null;
    } else {
      // 交点を計算
      double x = (other.b - b) / (a! - other.a!);
      double y = a! * x + b;
      return Point(x, y);
    }
  }


  /// 指定されたPointで垂直に交わる線を計算するメソッド
  Line perpendicularLineAtPoint(Point<double> point) {
    if (a == null) {
      // 垂直線に垂直な線は水平線
      return Line.fromPoints(point, Point(point.x + 1, point.y));
    } else if (a == 0) {
      // 水平線に垂直な線は垂直線
      return Line.fromPoints(point, Point(point.x, point.y + 1));
    } else {
      double perpendicularSlope = -1 / a!;
      double perpendicularIntercept = point.y - perpendicularSlope * point.x;
      return Line.fromPoints(point, Point(point.x + 1, perpendicularSlope * (point.x + 1) + perpendicularIntercept));
    }
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) || other is Line && a == other.a && b == other.b;
  }

  @override
  int get hashCode => Object.hash(a, b);


  @override
  String toString() {
    if (a == null) {
      return 'Line("y = $b", angle: $angleInDegree [Deg])';
    } else if (a == 0) {
      return 'Line("x = $b", angle: $angleInDegree [Deg])';
    } else {
      return 'Line("y = ${a}x + $b", angle: $angleInDegree [Deg])';
    }
  }
}

extension RectExt on Rect {
  Offset wrapOffset(Offset value) {
    return Offset(
      clampDouble(value.dx, left, right),
      clampDouble(value.dy, top, bottom),
    );
  }

  Point<double> wrapPoint(Point<double> value) {
    return Point(
      clampDouble(value.x, left, right),
      clampDouble(value.y, top, bottom),
    );
  }

  bool justConstraint(Offset e) => e.dx >= left && e.dx <= right && e.dy >= top && e.dy <= bottom;
}